{-
 - K-language grammar
 - by Piotr Dobrowolski 
 - (291528)
 -}

comment "//";
comment "/*" "*/";
comment "#";

entrypoints Program, Stm, Exp;

Progr.  Program ::= [DGlobalDeclaration];
terminator nonempty DGlobalDeclaration "";

--GLOBALS

DFunction.  DGlobalDeclaration ::= Function_def;
DGlobal.    DGlobalDeclaration ::= Dec;

OldFunc.     Function_def ::= Declaration_specifier Declarator [Dec] Compound_stm;
NewFunc.     Function_def ::= Declaration_specifier Declarator Compound_stm;
OldFuncInt.  Function_def ::= Declarator [Dec] Compound_stm;
NewFuncInt.  Function_def ::= Declarator Compound_stm;


NoDeclarator.  Dec ::= Declaration_specifier ";";
Declarators.   Dec ::= Declaration_specifier [Init_declarator] ";";

terminator nonempty Dec "";  

Type.   Declaration_specifier ::= Type_specifier;
NSType. Declaration_specifier ::= Type_namespace_specifier;

separator nonempty Init_declarator ",";

OnlyDecl.  Init_declarator ::= Declarator;
InitDecl.  Init_declarator ::= Declarator "=" Initializer;

--TYPES
rules Type_specifier ::= "int" | "float" | "bool" | Struct_spec;

--Const  . Type_qualifier ::= "const";
Namespace.  Type_namespace_specifier ::= Ident "::";

Tag.      Struct_spec ::= "struct" Ident "{" [Struct_dec] "}";
Unique.   Struct_spec ::= "struct" "{" [Struct_dec] "}";
TagType.  Struct_spec ::= "struct" Ident;

terminator nonempty Struct_dec "";

Structen. Struct_dec ::= Declaration_specifier [Struct_declarator] ";";

--terminator nonempty Spec_qual "";
--TypeSpec.  Spec_qual ::= Type_specifier;

separator nonempty Struct_declarator ",";

Decl.      Struct_declarator ::= Declarator;
Field.     Struct_declarator ::= ":" Constant_expression;
DecField.  Struct_declarator ::= Declarator ":" Constant_expression;

NoPointer.      Declarator ::= Direct_declarator;

Name.        Direct_declarator ::= Ident;
ParenDecl.   Direct_declarator ::= "(" Declarator ")";
NewFuncDec.  Direct_declarator ::= Direct_declarator "(" Parameter_type ")";
OldFuncDef.  Direct_declarator ::= Direct_declarator "(" [Ident] ")";
OldFuncDec.  Direct_declarator ::= Direct_declarator "(" ")";

AllSpec.  Parameter_type ::= Parameter_declaration;
MoreSpec. Parameter_type ::= Parameter_type "," Parameter_declaration;

OnlyType.      Parameter_declaration ::= Declaration_specifier;
TypeAndParam.  Parameter_declaration ::= Declaration_specifier Declarator;
--Abstract.      Parameter_declaration ::= Declaration_specifier Abstract_declarator;

separator nonempty Ident ",";

InitExpr.    Initializer ::= Exp2;
InitListOne. Initializer ::= "{" Initializers "}";
InitListTwo. Initializer ::= "{" Initializers "," "}";


AnInit.   Initializers ::= Initializer;
MoreInit. Initializers ::= Initializers "," Initializer;


PlainType.    Type_name ::= Declaration_specifier;
--ExtendedType. Type_name ::= Declaration_specifier Abstract_declarator;

--Advanced.        Abstract_declarator ::= Dir_abs_dec;


--WithinParentes.  Dir_abs_dec ::= "(" Abstract_declarator ")";
--OldFunction.     Dir_abs_dec ::= "(" ")";
--NewFunction.     Dir_abs_dec ::= "(" Parameter_type ")";
--OldFuncExpr.     Dir_abs_dec ::= Dir_abs_dec "(" ")";
--NewFuncExpr.     Dir_abs_dec ::= Dir_abs_dec "(" Parameter_type ")";


CompS.    Stm ::= Compound_stm;
ExprS.    Stm ::= Expression_stm;
SelS.     Stm ::= Selection_stm;
IterS.    Stm ::= Iter_stm;
JumpS.    Stm ::= Jump_stm;

ScompOne.   Compound_stm ::= "{" "}";
ScompTwo.   Compound_stm ::= "{" [Stm] "}";
ScompThree. Compound_stm ::= "{" [Dec] "}";
ScompFour.  Compound_stm ::= "{" [Dec] [Stm] "}";

SexprOne.   Expression_stm ::= ";";
SexprTwo.   Expression_stm ::= Exp ";";

SselOne.    Selection_stm ::= "if" "(" Exp ")" Stm;
SselTwo.    Selection_stm ::= "if" "(" Exp ")" Stm "else" Stm;

SiterOne.   Iter_stm ::= "while" "(" Exp ")" Stm;
SiterTwo.   Iter_stm ::= "do" Stm "while" "(" Exp ")" ";";
SiterThree. Iter_stm ::= "for" "(" Expression_stm Expression_stm ")" Stm;
SiterFour.  Iter_stm ::= "for" "(" Expression_stm Expression_stm Exp ")" Stm;

SjumpTwo.   Jump_stm ::= "continue" ";";
SjumpThree. Jump_stm ::= "break" ";";
SjumpFour.  Jump_stm ::= "return" ";";
SjumpFive.  Jump_stm ::= "return" Exp ";";

separator nonempty Stm "";
token CFloat (((digit+ '.' digit+)|(digit+ '.')|('.' digit+))(('e'|'E')('-')? digit+)?
                               ('f'|'F'))|((digit+ ('e'|'E')('-')? digit+)('f'|'F'));
token Boolean ('t''r''u''e' | 'f''a''l''s''e');

Ecomma.      Exp   ::= Exp "," Exp2;
Eassign.     Exp2  ::= Exp15 Assignment_op Exp2;
Econdition.  Exp3  ::= Exp4 "?" Exp ":" Exp3;
Elor.        Exp4  ::= Exp4 "||" Exp5;
Eland.       Exp5  ::= Exp5 "&&" Exp6;
Ebitor.      Exp6  ::= Exp6 "|" Exp7;
Ebitexor.    Exp7  ::= Exp7 "^" Exp8;
Ebitand.     Exp8  ::= Exp8 "&" Exp9;
Eeq.         Exp9  ::= Exp9 "==" Exp10;
Eneq.        Exp9  ::= Exp9 "!=" Exp10;
Elthen.      Exp10 ::= Exp10 "<" Exp11;
Egrthen.     Exp10 ::= Exp10 ">" Exp11;
Ele.         Exp10 ::= Exp10 "<=" Exp11;
Ege.         Exp10 ::= Exp10 ">=" Exp11;
Eleft.       Exp11 ::= Exp11 "<<" Exp12;
Eright.      Exp11 ::= Exp11 ">>" Exp12;
Eplus.       Exp12 ::= Exp12 "+" Exp13;
Eminus.      Exp12 ::= Exp12 "-" Exp13;
Etimes.      Exp13 ::= Exp13 "*" Exp14;
Ediv.        Exp13 ::= Exp13 "/" Exp14;
Emod.        Exp13 ::= Exp13 "%" Exp14;
Etypeconv.   Exp14 ::= "(" Type_name ")" Exp14;
Epreinc.     Exp15 ::= "++" Exp15;
Epredec.     Exp15 ::= "--" Exp15;
Epreop.      Exp15 ::= Unary_operator Exp14;
Efunk.       Exp16 ::= Exp16 "(" ")";
Efunkpar.    Exp16 ::= Exp16 "(" [Exp2] ")";
Eselect.     Exp16 ::= Exp16 "." Ident;
Epostinc.    Exp16 ::= Exp16 "++";
Epostdec.    Exp16 ::= Exp16 "--";
Evar.        Exp17 ::= Ident;
Econst.      Exp17 ::= Constant;
Estring.     Exp17 ::= String;


Efloat.        Constant ::= Double;
Ebool.         Constant ::= Boolean;
Ecfloat.       Constant ::= CFloat;
Eint.          Constant ::= Integer;  

--internal Elonger. Constant ::= Integer;
--internal Edouble. Constant ::= Double;

Especial. Constant_expression ::= Exp3;

coercions Exp 17;

Plus.        Unary_operator ::= "+";
Negative.    Unary_operator ::= "-";
Logicalneg.  Unary_operator ::= "!";

separator nonempty Exp2 ",";

Assign.       Assignment_op ::= "=";
AssignMul.    Assignment_op ::= "*=";
AssignDiv.    Assignment_op ::= "/=";
AssignMod.    Assignment_op ::= "%=";
AssignAdd.    Assignment_op ::= "+=";
AssignSub.    Assignment_op ::= "-=";
AssignLeft.   Assignment_op ::= "<<=";
AssignRight.  Assignment_op ::= ">>=";
AssignAnd.    Assignment_op ::= "&=";
AssignXor.    Assignment_op ::= "^=";
AssignOr.     Assignment_op ::= "|=";